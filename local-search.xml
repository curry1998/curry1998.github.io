<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git使用指南</title>
    <link href="/2024/01/13/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2024/01/13/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>git 是使用最多的版本控制系统，版本控制系统 (VCSs) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</p><p>Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作</p><h4 id="git-数据模型"><a href="#git-数据模型" class="headerlink" title="git 数据模型"></a>git 数据模型</h4><p>Git 将顶级目录中的文件和文件夹作为集合，并<strong>通过一系列快照来管理其历史记录</strong>。在Git的术语里，文件被称作Blob对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。</p><p>一个文件就是一个Blob 对象，一个目录对应一个 Tree。</p> <img src="/2024/01/13/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20240313113113759.png" class=""><p>这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个blob对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。</p><p>Git 数据模型伪代码如下： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 文件就是一组数据</span><br><span class="hljs-keyword">type</span> blob = array&lt;<span class="hljs-type">byte</span>&gt;<br><br><span class="hljs-comment">// 一个包含文件和目录的目录</span><br><span class="hljs-keyword">type</span> tree = <span class="hljs-keyword">map</span>&lt;<span class="hljs-type">string</span>, tree | blob&gt;<br><br><span class="hljs-comment">// 每个提交都包含一个父辈，元数据和顶层树</span><br><span class="hljs-keyword">type</span> commit = <span class="hljs-keyword">struct</span> &#123;<br>    parent: array&lt;commit&gt;<br>    author: <span class="hljs-type">string</span><br>    message: <span class="hljs-type">string</span><br>    snapshot: tree<br>&#125;<br></code></pre></td></tr></table></figure><p>Git 中的对象可以是 blob、树或提交：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">type</span> <span class="hljs-keyword">object</span> = blob | tree | <span class="hljs-keyword">commit</span><br></code></pre></td></tr></table></figure><p>Git 在储存数据时，所有的对象都会基于它们的 <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 哈希</a> 进行寻址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">objects = <span class="hljs-built_in">map</span>&lt;string, <span class="hljs-built_in">object</span>&gt;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">store</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):<br>    <span class="hljs-built_in">id</span> = sha1(<span class="hljs-built_in">object</span>)<br>    objects[<span class="hljs-built_in">id</span>] = <span class="hljs-built_in">object</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"><span class="hljs-built_in">id</span></span>):<br>    <span class="hljs-keyword">return</span> objects[<span class="hljs-built_in">id</span>]<br></code></pre></td></tr></table></figure><p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p><p>使用 git cat-file -p 某次object的hash值  可以查看相应具体内容</p> <img src="/2024/01/13/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20240313122054264.png" class=""><p>为了解决方便人们操作，Git 的给某些特定的哈希值赋予可读的名称，<code>master</code> 引用通常会指向主分支的最新一次提交，<code>HEAD</code>，指向当前分支的最新提交，<code>origin</code> 是默认的远程仓库名称。</p><h4 id="git-命名行接口"><a href="#git-命名行接口" class="headerlink" title="git 命名行接口"></a>git 命名行接口</h4><p>参考文章： <a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p><p>基础</p><ul><li><p><code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息</p></li><li><p><code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为 <code>.git</code> 的目录下</p></li><li><p><code>git status</code>: 显示当前的仓库状态</p></li><li><p><code>git add &lt;filename&gt;</code>: 添加文件到暂存区</p></li><li><p><code>git commit -m &quot;&quot;</code></p><p>: 创建一个新的提交</p><ul><li>如何编写 <a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">良好的提交信息</a>!</li><li>为何要 <a href="https://chris.beams.io/posts/git-commit/">编写良好的提交信息</a></li></ul></li><li><p><code>git log</code>: 显示历史日志</p></li><li><p><code>git log --all --graph --decorate</code>: 可视化历史记录（有向无环图）</p></li><li><p><code>git show</code>  查看具体的修改信息</p></li><li><p><code>git diff &lt;filename&gt;</code>: 显示与暂存区文件的差异</p></li><li><p><code>git diff &lt;revision&gt; &lt;filename&gt;</code>: 显示某个文件两个版本之间的差异</p></li><li><p><code>git checkout &lt;revision&gt;</code>: 更新 HEAD 和目前的分支</p></li></ul><p>分支和合并</p><ul><li><p><code>git branch</code>: 显示分支</p></li><li><p><code>git branch &lt;name&gt;</code>: 创建分支</p></li><li><pre><code class="plaintext">git checkout -b &lt;name&gt;</code></pre><p>: 创建分支并切换到该分支</p><ul><li>相当于 <code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li></ul></li><li><p><code>git merge &lt;revision&gt;</code>: 合并到当前分支。 git merge 会多一条提交记录。merge操作遇到冲突时候，当前merge不能继续下去。手动修改冲突内容后，add 修改，commit 就可以了。git merge –abort   <em>终止合并</em></p></li><li><p><code>git mergetool</code>: 使用工具来处理合并冲突</p></li><li><p><code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线, 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p> <img src="/2024/01/13/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20240313182436583.png" class=""><p><code>rebase</code> 的执行过程是首先找到这两个分支（即当前分支 <code>Feature</code>、 <code>rebase</code> 操作的目标基底分支 <code>Master</code>） 的最近共同祖先提交 A，然后对比当前分支相对于该祖先提交的历次提交（D 和 E），<strong>提取相应的修改并存为临时文件</strong>，然后将当前分支指向目标基底 <code>Master</code> 所指向的提交 C, <strong>最后以此作为新的基端将之前另存为临时文件的修改依序应用</strong>。</p><p>Git rebase  时出现冲突，解决冲突后，<strong>git add 后执行git rebase –continue 不要 commit</strong>， git rebase 是按照一条一条执行的 commit 信息的。  <a href="https://stackoverflow.com/questions/7241678/how-to-prevent-many-git-conflicts-when-rebasing-many-commits">如何在 rebase 多次提交时防止多次 git 冲突？</a></p></li></ul><p>远端操作</p><ul><li><code>git remote</code>: 列出远端</li><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加一个远端</li><li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: 将对象传送至远端并更新远端引用</li><li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: 创建本地和远端分支的关联关系</li><li><code>git fetch</code>: 从远端获取对象&#x2F;索引</li><li><code>git pull</code>: 相当于 <code>git fetch; git merge</code></li><li><code>git clone</code>: 从远端下载仓库</li></ul><p>撤销</p><ul><li><code>git commit --amend</code>: 编辑提交的内容或信息, 如果您只想修改提交消息而不更改提交的内容，可以添加 <code>--only</code> 选项。</li><li><code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件</li><li><code>git checkout -- &lt;file&gt;</code>: 丢弃修改</li><li><code>git restore</code>: git2.32版本后取代git reset 进行许多撤销操作,把文件从缓存区撤销，回到未被追踪的状态。</li></ul><p>Git 高级操作</p><ul><li><code>git config</code>: Git 是一个 <a href="https://git-scm.com/docs/git-config">高度可定制的</a> 工具</li><li><code>git clone --depth=1</code>: 浅克隆（shallow clone），不包括完整的版本历史信息</li><li><code>git add -p</code>: 交互式暂存</li><li><code>git rebase -i</code>: 交互式变基</li><li><code>git blame</code>: 查看最后修改某行的人</li><li><code>git stash</code>: 暂时移除工作目录下的修改内容， git stash save、 git stash apply</li><li><code>git bisect</code>: 通过二分查找搜索历史记录</li><li><code>.gitignore</code>: <a href="https://git-scm.com/docs/gitignore">指定</a> 故意不追踪的文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>研发工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GFS读写流程</title>
    <link href="/2023/07/08/GFS%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/07/08/GFS%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>Google 文件系统（GFS）是 Google 开发的分布式文件系统，用于存储大规模数据集。本文对客户端与GFS之间文件读写的流程进行详解。</p><h4 id="GFS-整体架构"><a href="#GFS-整体架构" class="headerlink" title="GFS 整体架构"></a>GFS 整体架构</h4><p>Google 文件系统（GFS）的大体架构包括三个关键组件：主节点（master）、分片服务器（chunk servers）和客户端（clients）。下面是 GFS 的大体架构及其组件的功能：</p><ol><li><strong>主节点（Master）</strong>：<ul><li><strong>元数据管理</strong>：主节点负责管理文件系统的元数据，包括文件、目录和数据块的命名空间、数据块的位置和副本信息等。</li><li><strong>命名空间操作</strong>：主节点处理客户端的命名空间操作请求，如创建文件、删除文件、重命名等。</li><li><strong>数据块分配</strong>：主节点负责为文件的数据块分配存储位置，确定数据块的副本数，并管理数据块的迁移和复制。</li></ul></li><li><strong>分片服务器（Chunk Servers）</strong>：<ul><li><strong>数据存储</strong>：分片服务器存储实际的数据块，并处理客户端的读写请求。</li><li><strong>数据复制和迁移</strong>：分片服务器负责处理数据块的复制和迁移操作，以保证数据的可靠性和高可用性。</li><li><strong>心跳检测</strong>：分片服务器定期向主节点发送心跳信号，报告其状态和可用性。</li></ul></li><li><strong>客户端（Clients）</strong>：<ul><li><strong>文件访问</strong>：客户端负责向 GFS 发送文件读写请求，并与主节点和分片服务器进行通信。</li><li><strong>数据缓存</strong>：客户端可能会缓存部分数据块以提高性能，并将修改后的数据块写回到 GFS 中。</li><li><strong>错误处理</strong>：客户端处理数据访问过程中可能出现的错误，并向用户报告错误信息。</li></ul></li></ol><p>除了上述的关键组件外，GFS 的架构还包括了一些其他的辅助组件，如心跳管理、数据块迁移策略、数据一致性保证等，这些组件共同协作，构成了 GFS 的分布式存储系统。GFS 的设计目标是提供高可靠性、高可用性和高性能的大规模文件存储服务。</p><h4 id="Master-主要的两个表单"><a href="#Master-主要的两个表单" class="headerlink" title="Master 主要的两个表单"></a>Master 主要的两个表单</h4><p>客户端要从chunkserver 上读写文件首先要发请求给Master获取文件相关的数据。将数据缓存到客户端本地（后面将介绍为什么要这么做）。根据相关数据与chunkserver 进行交互，实现文件的读写。每个chunk 的大小为64MB。Master主要有两个表单来存储相关的元数据（注意有的元数据需要持久化到硬盘，有的只存放在内存，后面将介绍为什么这样做)。<br>两个表单如下：</p><ol><li>文件名到chunk ID 或者 chunk Handle 数组（文件较大会对应多个chunk ID,多个chunkID 组成chunk Handle 数组）的对应。</li><li>chunkID 到 chunk 数据的对应关系（如下）。<blockquote><p>2.1 每个chunk （论文中说，一个chunkID 一般有三个副本及三个chunk ）存储在哪个服务器上。（list of chunkserver） （不持久化到master 磁盘）<br>2.2 每个chunk 当前版本(version)。设置版本主是为了检测过期失效的副本。版本号只会在master指定一个新的Primary才会改变（持久化到master磁盘）<br>2.3 哪个chunk 服务器有主chunk(primary). gfs引入了租约来最小化master 节点的管理负担。（持久化到master 磁盘）<br>2.4 租约的过期时间（lease expiration）. gfs 默认过期时间是60s（可以修改）</p></blockquote></li></ol><p>租约(lease)介绍：lease 是数据库中的一个术语。Master 节点为chunk的一个副本建立一个租约，这个副本就做主chunk(primary),主chunk对chunk的 所有更改操作进行序列化，所有副本都遵循这个序列进行修改操作。</p><h4 id="读-文-件-流-程"><a href="#读-文-件-流-程" class="headerlink" title="读 文 件 流 程"></a>读 文 件 流 程</h4><p>client 将文件名，及从文件哪个位置读取的偏移量(offset)发送给master,master主要做下面三个操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1.</span> 从file 表单中查文件名<br><span class="hljs-number">2.</span> 文件偏移量/<span class="hljs-number">64</span>MB=chunk ID (多个组成chunk Handle)<br><span class="hljs-number">3.</span> 从表单中将chunk Handle 和对应chunk服务器列表发送给客户端。<br></code></pre></td></tr></table></figure><p>客户端可以从这些Chunk服务器中挑选一个来读取数据。GFS论文说，客户端会选择一个网络上最近的服务器（Google的数据中心中，IP地址是连续的，所以可以从IP地址的差异判断网络位置的远近），并将读请求发送到那个服务器。因为客户端每次可能只读取1MB或者64KB数据，所以，客户端可能会连续多次读取同一个Chunk的不同位置。所以，客户端会缓存Chunk和服务器的对应关系，这样，当再次读取相同Chunk数据时，就不用一次次的去向Master请求相同的信息。</p><p>  接下来，客户端会与选出的Chunk服务器通信，将Chunk Handle和偏移量发送给那个Chunk服务器。Chunk服务器会在本地的硬盘上，将每个Chunk存储成独立的Linux文件，并通过普通的Linux文件系统管理。并且可以推测，Chunk文件会按照Handle（也就是ID）命名。所以，Chunk服务器需要做的就是根据文件名找到对应的Chunk文件，之后从文件中读取对应的数据段，并将数据返回给客户端。</p><p>读数据跨chunk的边界：</p><p>客户端本身依赖了一个GFS的库，这个库会注意到读请求跨越了Chunk的边界 ，并会将读请求拆分，之后再将它们合并起来。所以这个库会与Master节点交互，Master节点会告诉这个库说Chunk7在这个服务器，Chunk8在那个服务器。之后这个库会说，我需要Chunk7的最后两个字节，Chunk8的头两个字节。GFS库获取到这些数据之后，会将它们放在一个buffer中，再返回给调用库的应用程序。Master节点会告诉库有关Chunk的信息，而GFS库可以根据这个信息找到应用程序想要的数据。应用程序只需要确定文件名和数据在整个文件中的偏移量，GFS库和Master节点共同协商将这些信息转换成Chunk。</p><h4 id="写文件流程"><a href="#写文件流程" class="headerlink" title="写文件流程"></a>写文件流程</h4><p>client——–&gt;Master 发送请求，表示想要向这个文件名对应的文件追加数据,告诉我最后一个chunk 的位置。写文件通过chunk的的主副本（primary chunk）写入。<br>流程如下:</p> <img src="/2023/07/08/GFS%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B/image-20240302212925999.png" class=""><p>◆客户机向Master节点询问哪一个Chunk服务器持有当前的租约，以及其它副本的位置。如果没有一个Chunk持有租约，Master节点就选择其中一个副本建立一个租约（这个步骤在图上没有显示)。</p><p>◆ Master节点将主Chunk的标识符以及其它副本（又称为secondary副本、二级副本）的位置返回给客户机。客户机缓存这些数据以便后续的操作。只有在主Chunk不可用，或者主Chunk回复信息表明它已不再持有租约的时候，客户机才需要重新跟Master节点联系。</p><p>◆ 客户机把数据推送到所有的副本上。客户机可以以任意的顺序推送数据。Chunk服务器接收到数据并保存在它的内部LRU缓存中，一直到数据被使用或者过期交换出去。由于数据流的网络传输负载非常高，通过分离数据流和控制流，我们可以基于网络拓扑情况对数据流进行规划，提高系统性能，而不用去理会哪个Chunk服务器保存了主Chunk。</p><p>◆当所有的副本都确认接收到了数据，客户机发送写请求到主Chunk服务器。这个请求标识了早前推送到所有副本的数据。主Chunk为接收到的所有操作分配连续的序列号，这些操作可能来自不同的客户机，序列号保证了操作顺序执行。它以序列号的顺序把操作应用到它自己的本地状态中（alex注：也就是在本地执行这些操作，这句话按字面翻译有点费解，也许应该翻译为“它顺序执行这些操作，并更新自己的状态”）。</p><p>◆主Chunk把写请求传递到所有的二级副本。每个二级副本依照主Chunk分配的序列号以相同的顺序执行这些操作。</p><p>◆所有的二级副本回复主Chunk，它们已经完成了操作。</p><p>◆主Chunk服务器（主Chunk所在的Chunk服务器）回复客户机。任何副本产生的任何错误都会返回给客户机。在出现错误的情况下，写入操作可能在主Chunk和一些二级副本执行成功。（如果操作在主Chunk上失败了，操作就不会被分配序列号，也不会被传递。）客户端的请求被确认为失败，被修改的region处于不一致的状态。我们的客户机代码通过重复执行失败的操作来处理这样的错误。在从头开始重复执行之前，客户机会先从步骤（3）到步骤（7）做几次尝试。</p><p>如果应用程序一次写入的数据量很大，或者数据跨越了多个Chunk，GFS客户机代码会把它们分成多个写操作。这些操作都遵循前面描述的控制流程，但是可能会被其它客户机上同时进行的操作打断或者覆盖。因此，共享的文件region的尾部可能包含来自不同客户机的数据片段，尽管如此，由于这些分解后的写入操作在所有的副本上都以相同的顺序执行完成，Chunk的所有副本都是一致的。这使文件region处于2.7节描述的一致的、但是未定义的状态。</p><h5 id="primary-chunk-不存在"><a href="#primary-chunk-不存在" class="headerlink" title="primary chunk 不存在"></a>primary chunk 不存在</h5><p>当Chunk服务器失效时，Chunk的副本有可能因错失了一些修改操作而过期失效。Master节点保存了每个Chunk的版本号，用来区分当前的副本和过期副本。<br>无论何时，只要Master节点和Chunk签订一个新的租约，它就增加Chunk的版本号，然后通知最新的副本。<code>Master节点和这些副本都把新的版本号记录在它们持久化存储的状态信息中。</code>这个动作发生在任何客户机得到通知以前，因此也是对这个Chunk开始写之前。如果某个副本所在的Chunk服务器正好处于失效状态，那么副本的版本号就不会被增加。Master节点让这个Chunk服务器重新启动，并且向Master节点报告它拥有的Chunk的集合以及相应的版本号的时候，就会检测出它包含过期的Chunk。如果Master节点看到一个比它记录的版本号更高的版本号，Master节点会认为它和Chunk服务器签订租约的操作失败了，因此会选择更高的版本号作为当前的版本号。</p><p>Master节点在例行的垃圾回收过程中移除所有的过期失效副本。在此之前，Master节点在回复客户机的Chunk信息请求的时候，简单的认为那些过期的块根本就不存在。另外一重保障措施是，Master节点在通知客户机哪个Chunk服务器持有租约、或者指示Chunk服务器从哪个Chunk服务器进行克隆时，消息中都附带了Chunk的版本号。客户机或者Chunk服务器在执行操作时都会验证版本号以确保总是访问当前版本的数据。</p><h5 id="脑裂-split-brain"><a href="#脑裂-split-brain" class="headerlink" title="脑裂 split-brain"></a>脑裂 split-brain</h5><p>脑裂，它通常是由网络分区引起的。比如说，Master无法与Primary通信，但是Primary又可以与客户端通信，这就是一种网络分区问题。网络故障是这类分布式存储系统中最难处理的问题之一。</p><p>在某个时间点，Master指定了一个Primary，之后Master会一直通过定期的ping来检查它是否还存活。因为如果它挂了，Master需要选择一个新的Primary。Master发送了一些ping给Primary，并且Primary没有回应，你可能会认为Master会在那个时间立刻指定一个新的Primary。但事实是，这是一个错误的想法。为什么是一个错误的想法呢？因为可能是网络的原因导致ping没有成功，所以有可能Primary还活着，但是网络的原因导致ping失败了。但同时，Primary还可以与客户端交互，如果Master为Chunk指定了一个新的Primary，那么就会同时有两个Primary处理写请求，这两个Primary不知道彼此的存在，会分别处理不同的写请求，最终会导致有两个不同的数据拷贝。这被称为脑裂（split-brain）。所以在master ping不通primary 时需要等lease 过期后才能分配新的primary。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>企业家精神</title>
    <link href="/2023/06/02/%E4%BC%81%E4%B8%9A%E5%AE%B6%E7%B2%BE%E7%A5%9E/"/>
    <url>/2023/06/02/%E4%BC%81%E4%B8%9A%E5%AE%B6%E7%B2%BE%E7%A5%9E/</url>
    
    <content type="html"><![CDATA[<h4 id="1-什么是企业家"><a href="#1-什么是企业家" class="headerlink" title="1. 什么是企业家"></a>1. 什么是企业家</h4><p><strong>市场经济&#x3D;价格+企业家。</strong>如果说价格是市场经济的非人格化机制，企业家则是市场经济的人格化主体。</p><p><strong>企业家的两种基本职能：发现不均衡和创造不均衡。</strong></p><h4 id="2-企业家与市场过程"><a href="#2-企业家与市场过程" class="headerlink" title="2. 企业家与市场过程"></a>2. 企业家与市场过程</h4><p> <strong>企业家在市场运作过程中所起的作用是至关重要的，但主流经济学一直忽略企业家，甚至在大多数的教科书中，“企业家”三个字都难觅踪迹。</strong>一个原因和主流经济学的分析方法相关。主流经济学已经演化得相当数学化了，而企业家行为很难用数学表述，所以经济学家在构建理论时就不得不“削足适履”，放弃了对企业家的分析。另一个原因则根源于主流经济学的假设。<strong>主流经济学通常以“完全理性”“完全信息”作为推理的前提假设，在这种假设下，市场很容易达到均衡状态，企业家是没有存在的必要的。</strong></p><p>​市场看上去是个很奇怪的东西。我们无须向任何企业预先提交订单，但是只要我们有足够的钱，就能从市场购买到我们想购买且能够支付的任何东西。资源配置似乎会在悄无声息中得到优化。即使没有人去鼓励创新，市场上的新产品、新技术也会不断涌现出来，让消费者的福利不断得到改善。</p><p>​<strong>价格不会自己决定，究竟是谁操纵了它？新产品不会自行产生，究竟是谁创造了它？工作机会不会自行出现，究竟是谁提供了它？事实上，完成这一切的都是同一个特殊人群——企业家。</strong></p><p>​<strong>企业家：“以盈利为目的而提供产品和服务的人。</strong>无论是价格的决定、新产品的提供，还是工作机会的创造，都是企业家在“有意”追逐利润的过程中产生的“无意”结果。企业家赚的利润是经济利润。经济利润存在的前提，是不确定性（uncertainty）的存在。商界有一句话，叫“世界上唯一确定的就是不确定”。</p><h4 id="3-企业家职责"><a href="#3-企业家职责" class="headerlink" title="3.企业家职责"></a>3.企业家职责</h4><p>如果世界是确定不变的，或者即使有变化，也可以预测到，那么竞争很快就会让市场趋向均衡。在均衡状态，市场上没有企业能获得正的经济利润，也没有潜在的企业愿意进入市场。但是，世界当然不可能是确定的（市场并不是有效的），这种静态的均衡也显然不是市场的常态。</p><p>企业家的基本职能可以分为两类：<strong>一是发现不均衡，二是创造不均衡。</strong></p><ul><li><strong>所谓发现不均衡，就是发现供给和需求不一致导致的盈利机会。eg: 将中国的小商品卖到美国，将美国的电子产品卖到中国。</strong></li></ul><p>对于追逐利润的企业家而言，一旦发现了市场中的不均衡，并利用不均衡来进行套利，就可能获得超常的利润。而无数企业家的套利行为，则会逐步修正市场的错误，让市场中的资源配置变得更加有效。与此同时，市场上的利润机会将会变得越来越少，市场会逐渐趋向均衡。</p><ul><li><strong>通过创新（innovation）活动改变需求曲线和供给曲线，打破原来的市场均衡，并创造出新的潜在均衡。在这个过程中，企业家将通过创造新的产品和新的技术为消费者增加价值，或使得资源的生产率得到提高。</strong>，<strong>eg: 乔布斯的智能手机。</strong></li></ul><p><strong>套利： 通过发现和利用市场上的资源错配获利。</strong></p><p><strong>创新：通过创造新产品和新技术为消费者增加价值，或提高资源的生产率。</strong></p><p>除了套利和创新外，<strong>企业家还需要担负管理者、资本家等职能，有时候企业家还是发明家</strong>。企业家的职能可能有很多，但核心的职能是发现不均衡和创造不均衡，其他的职能都是派生出来为这两个核心职能服务的。</p><p>企业家的类型：</p><ol><li>按订单生产的企业家。这类企业家完全按照消费者的需求组织生产，他们所需要关心的，是怎么才能用更低的成本来生产同样的产品。我们现在说的“中国制造”，很大程度上都是由这类企业家推动的。</li><li>满足市场上已经表现出来的需求的企业家。<strong>这类企业家关心的，是怎样做出比别人更好的商品。</strong>那些关心怎么让现在的汽车跑得更快、坐得更舒服、用油更省，或者怎么让现在的电脑功能更多、运算速度更快的企业家，都属于这一类别。 eg: 福耀玻璃 </li><li><strong>识别消费者自己都没有明白的需求的企业家。</strong>这类企业家是最了不起的，他们的工作不仅满足了现有的需求，而且创造出了新的产品、新的产业、新的需求，是“从无到有”。盖茨、乔布斯、马云、马化腾等，都可以归入这一类企业家。</li></ol><h4 id="4-创造不均衡和创新"><a href="#4-创造不均衡和创新" class="headerlink" title="4.创造不均衡和创新"></a>4.创造不均衡和创新</h4><p>企业家的第二个功能是创造不均衡。如果均衡点不发生变动，那么企业家的套利行为终究会让市场趋向均衡，此时竞争会让所有的企业家都无利可图。为了继续获得利润，企业家们必须打破原有的均衡，建立起新的潜在均衡。</p><p>要打破均衡，靠的是创新。什么是创新呢？<strong>简而言之，就是对生产要素的重新组合（new combination of production factors），是对需求函数和供给函数的根本改变。</strong></p><p>“<strong>创新之父”的熊彼特曾经将创新归纳为五个方面：</strong> <strong>（1） 引入新产品；（2） 引进新技术（即新的生产方式）；（3） 开辟新市场；（4） 发现新的原材料；（5） 实现新的组织或管理方式（模式上的创新）。</strong></p><p>无论是以上哪个方面的创新，都可能造成供给曲线或需求曲线（或者两条曲线一起）的移动，从而打破“低销量，高价格”的旧均衡，实现“高销量，低价格”的新均衡。 eg: 汽车从贵族的玩物，到逐步走入寻常百姓家，是无数企业家不断努力的成果。而在这些企业家中，最重要的就是著名的亨利·福特。 个人电脑。</p><p><strong>企业家的创新多种多样，但有两个重要的基本点：一是创造价值，二是降低产品的生产成本。</strong></p><ol><li><strong>创造价值，就是生产消费者喜欢的新产品或增加产品给消费者带来的效用。创造价值的关键是把握消费者的需求。</strong>消费者需要什么，他们不会直接告诉你，甚至他们自己也不清楚，因此企业家只有自己去猜。如果猜对了，创新就成功了，价值的提升可以让企业家的利润和消费者剩余同时提高；如果猜错了，创新就失败了，企业家就会亏损。为了成功预测需求，企业家就需要对人性和人心都有深刻的洞见。 eg: iphone 手机</li><li><strong>所谓降低成本，不是指去克扣工人的工资，也不是降低对供应商的支付，而是通过改良技术或组织效率来降低生产或消费商品的机会成本。</strong>通过这种努力，即使商品的总体价格下降了，企业家也可能在使消费者剩余得到提升的同时，让自己获得利润。</li></ol><p>任何新产品的引入，只有在该产品给消费者带来的总价值大于生产成本时，才能取得成功。生产者要增加利润，就必须或者通过创新提高总价值，或者通过创新降低成本，或者二者兼而有之，这就是创新的真正含义。既不能增加总价值又不能降低成本的创新，是不可能成功的。</p><p>当然，<strong>创新是一个持续的试错过程，我们上面说的价值与成本的关系是就创新的最终结果而言的，并不一定适用于创新的最初阶段。</strong>恰恰相反，一般来说，在创新的最初阶段，新产品的总价值通常小于成本，创新者不仅没有利润可赚，还要赔钱。这也是创新需要风险资本的原因。</p><p><strong>创新型企业家必须通过不断改进生产技术和产品质量，一方面提高总价值，另一方面降低生产成本。只有当价值曲线和成本曲线过了某个临界点，新产品才开始赚钱。</strong>eg: 索尼公司1956年开发出家庭录像机时，售价是5万美元，根本没有市场。经过20年的努力，索尼公司把售价降低到500美元时，家庭录像机才普及开来。</p><p>套利是一开始最赚钱，之后利润逐渐减少；创新是一开始亏钱，到一定时点之后才开始赚钱，然后利润上升，再到一定时点后，由于模仿者的竞争而使利润逐渐减少。</p><p><strong>创新者的窘境</strong></p><p>在历史上，有过很多伟大的公司，例如柯达、诺基亚等，在它们强盛的时候都被认为是不可战胜的。但这些伟大的公司最终却被一些名不见经传的新对手所击败，从而走向败亡。为什么这些伟大的公司都难免衰落呢？管理学家克里斯坦森在其著作《创新者的窘境》中对此进行了探讨。</p><p>据克里斯坦森的分类，<strong>创新有两种：维持性创新和破坏性创新。</strong>维持性创新是以挑剔的高端产品消费者为目标的，而破坏性创新则并不以为现有消费者提供更好的产品为目标，而是引入与现有产品相比不够好的产品或服务。<strong>与维持性创新相比，破坏性创新的产品往往具有更为简单、更为便捷或更为廉价等突出特征。</strong></p><p>在开始时，在市场上占据主导地位的公司只会把注意力放在主流消费群上，而不会在乎那些处于边缘的消费者，因此即使发现有一些小公司进行了“破坏性创新”也不会在意。但很快，它们就会发现那些“破坏性创新”已迅速开发出了一个庞大的市场，而大公司再想把那些创新的企业挤出市场就为时已晚了。</p><p>克里斯坦森的这一理论解释了很多伟大企业的覆灭。<strong>以诺基亚公司为例，其实这家曾经的手机业巨头早已掌握了开发智能手机的技术，但由于它错误地认为智能手机不会是未来手机发展的方向，因此当苹果推出iPhone时，诺基亚还在专注地思考怎么让传统手机更耐用。结果，正是那些耐用性较差、却更花哨、更好玩的iPhone，最终成为诺基亚王朝的掘墓人。</strong></p><p>企业家的利润导向</p><p><strong>企业家的创新是利润导向的，利润可以传递信息，它会告诉企业家他的所作所为是否被消费者接受，是否有社会价值。</strong>企业家无论是进行套利还是进行创新，都需要以利润作为风向标。</p><p>利润是衡量企业家活动成功与否的关键。企业家不同于发明家，一个发明家可以胡思乱想，但是企业家不同，如果没有市场就没有利润，也就没有商业意义上的创新。</p><h4 id="5-企业家成功的内在素质和外部环境"><a href="#5-企业家成功的内在素质和外部环境" class="headerlink" title="5.企业家成功的内在素质和外部环境"></a>5.企业家成功的内在素质和外部环境</h4><p>企业家的成功，是很多条件偶合的结果。只有当企业家具有过硬的内在素质，又拥有良好的外部环境时，他才可能成为优秀的企业家。企业家需要的素质至少包括如下几个方面：</p><ol><li>首先是对成功的渴望。对于利润的追求应该是永无止境的。</li><li>其次是对盈利机会的警觉（alertness）。发现市场的不均衡，并用它来进行套利，是企业家的一项基本职能。只有那些擅长发现并满足他人渴望和需求的企业家才能在瞬息万变的市场环境中准确地找到机会，成功实现套利。</li><li>再次是要有愿景（vision）和判断未来的能力。优秀的企业家，必须是能够洞察未来的人。他们需要判断未来的产业会怎么样，未来的消费者会有怎样的需求。只有成功地预料到了这些，企业家才能成功投机，成功实现满足消费者需求的创新。</li><li>最后是要有承担风险的勇气。风险和失败对于企业家来说是很常见的，包括福特、马云、周鸿祎在内，诸多优秀的企业家在其创业初期都曾经历过很多的挫折，甚至惨痛的失败。如果这个时候他们选择了放弃，那么他们就只能是一个平庸者。正是坚定的信心和百折不挠的勇气，造就了他们最终的成功。</li></ol><p>制度环境：创业和创新的自由、有效的产权保护和法治、稳定的政策预期，以及自由的金融体制。</p><ol><li><strong>首先是创业和创新的自由。</strong>企业家的事业都从创业开始，创业意味着独立地从事营利性商业活动，为此，<strong>企业家必须有权决定做什么和不做什么</strong>，能够从市场上获得必要的资源，有签订合同的自由，并自由决定把产品卖给谁，等等。创新是做别人没有做过的事情，它的成败只能来自市场的检验。如果没有创业和创新的自由，如果政府对创业和创新有太多的限制，企业家的才能就没有办法得到发挥，这是计划经济下没有企业家的根本原因。</li><li><strong>其次是有效的产权保护和法治。</strong>企业家的活动是一项长期的、艰辛的事业，只有当企业家能够享受成功带来的喜悦和利润的时候，他才会从事这样的事业。因此，有效的产权保护和法治就显得十分重要。</li><li><strong>再次是稳定的政策预期。</strong>在现代市场经济中，政府会用各种各样的政策干预市场的运行。对于企业家来说，政策不确定已成为最大的不确定。如果政策朝令夕改，就会对企业家判断未来造成不必要的麻烦，阻碍他们对市场走向做出判断。</li><li><strong>最后是自由的金融体制。</strong>企业家是有想法的人，但要把想法变成市场上可以出售的产品，他们必须首先有资金购买必要的生产要素。<strong>特别是对创新活动来说，由于在新产品和新技术能够赚钱之前，通常要经历很长时间的亏损，如果没有自由的金融体制，他们就不可能获得创新所需要的资本。</strong>在一个金融不自由的国家，企业家在创新方面一定乏善可陈。</li></ol><h4 id="6-有效市场悖论"><a href="#6-有效市场悖论" class="headerlink" title="6.有效市场悖论"></a>6.有效市场悖论</h4><p>1970年，芝加哥大学尤金·法玛（Eugene Fama）教授在一篇论文中提出了著名的“有效市场”假说。</p><p>有效市场”假说有三种版本。其中，“弱有效”（weak form）版本认为，当前的价格反映了所有过去价格中包含的信息，因此价格是“随机行走”（random walk），人们不可能通过研究过去的价格赚钱；“半强有效”（semi-strong form）版本认为，当前的价格不仅反映过去的价格，也反映了所有公开的信息，这意味着，任何公开的信息立即反映在价格中；而“强有效”（strong form）版本则认为，当前的价格反映了所有的信息，无论是公开的还是没有公开的，所以赚钱全是凭运气。]，但<strong>其核心思想不外乎是，如果金融市场是良好运作的，那么股票价格总是反映了股票的真实价值（等于预期收入流的贴现值），因此想利用信息在股市上赚钱是不可能的。</strong></p><p>有效市场理论的悖论是：如果股票的价格在任何时刻都等于股票的内在价值，也就是说，股票价格在任何时候都完全、无偏地反映了投资者所拥有的信息，那么，一个投资者完全可以不去从事收集、分析信息的工作，而是直接从股票的市场价格上推导出市场上所有的关于股票内在价值的信息。因为收集、分析信息都是要付出成本的。这样，在有效资本市场上，没有信息的投资者就不会去收集和分析信息。但是，如果所有的投资者都不去收集、分析信息，股票价格就不能有效地反映股票的价值。因此，正如Grossman和Stiglitz（1980）指出的，和有效资本市场理论的结论相反，</p><p><strong>为了讽刺“有效市场”理论的荒谬，人们甚至编出了一个笑话：假设地上有100元钱，经济学家一定会告诉你那是假钞。因为如果市场是有效的，真钞早就会被人捡走了。</strong></p><p>无论是空间上的不均衡还是时间上的不均衡，企业家的套利行为所能赚得的利润都与不均衡程度相关。市场偏离均衡越远，套利行为越有利可图。一般来说，一开始，只有少数企业家发现不均衡并抓住机会套利，因此他们可以赚很高的利润，但随着时间的推移，高利润就会吸引更多的企业家进入市场。当越来越多的企业家进入市场时，企业家之间的竞争就越来越激烈，不均衡程度就逐步降低，从而使得利润逐步减少，直至为零，如图8-4所示。此时，就不会有新的企业家进入，原来已进入的企业家也有些会退出。</p><h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h4><p>市场的运作不是静态的均衡，而是动态的过程，市场过程是企业家活动的结果。企业家是以盈利为目的而提供产品和服务的人。和普通工人不同，企业家赚取的不是合同收入，而是剩余收入。为了获得剩余收入，他们需要承担市场中的不确定性。</p><p>企业家的主要职能有两个：一是发现不均衡，二是创造不均衡。</p><p>所谓发现不均衡是在不同地区之间、不同时间之间，以及要素市场上发现潜在的盈利机会，并利用它们实现套利。而所谓创造不均衡，则是借助创新来打破原有的市场均衡，实现新的均衡。除此之外，企业家还可能担负管理者、发明家、资本家等职能。</p><p>企业家可以分为三类：第一类企业家是按订单生产的企业家；第二类企业家是满足市场上已经表现出来的需求的企业家；第三类企业家是识别消费者自己都没有明白的需求的企业家。同一个企业家在其职业生涯的不同阶段可能会扮演以上三种不同的角色。</p><p>企业家的成功是内在素质和外部环境共同作用的结果。从内在素质上看，成功的企业家需要有对成功的渴望、对盈利机会的警觉、判断未来的能力和承担风险的勇气。而从外部环境上看，企业家需要有完善的产权保护制度和稳定的政策预期。政府的产业政策不仅不能替代企业家，而且可能会干扰企业家的判断。</p>]]></content>
    
    
    <categories>
      
      <category>经济</category>
      
    </categories>
    
    
    <tags>
      
      <tag>企业家</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue中mounted方法与js定时器使用</title>
    <link href="/2023/03/02/vue%E4%B8%ADmounted%E6%96%B9%E6%B3%95%E4%B8%8Ejs%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/03/02/vue%E4%B8%ADmounted%E6%96%B9%E6%B3%95%E4%B8%8Ejs%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在常见的博客中都会这样写到</p><blockquote><p>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。<br>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</p></blockquote><hr><p>在实际的开发过程中我们会经常使用create方法，在页面还未渲染成html前，调用函数，从后端获取数据，在实现对页面的数据进行显示。比如说下面例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br><br>      <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">orderNo</span>=<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOrderInfo</span>()<br>    &#125;,<br>    <span class="hljs-attr">methods</span>:&#123;<br>      <span class="hljs-title function_">getOrderInfo</span>(<span class="hljs-params"></span>)&#123;<br>        order.<span class="hljs-title function_">getOrderByNum</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">orderNo</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resp</span>=&gt;</span>&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">order</span>=resp.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">data</span><br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-variable language_">this</span>.<span class="hljs-property">order</span>))<br>          <span class="hljs-comment">//根据订单中的老师id，获取老师姓名</span><br>          <span class="hljs-title function_">getDetailTeacher</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">order</span>.<span class="hljs-property">teacherName</span>).<span class="hljs-title function_">then</span>(<br>            <span class="hljs-function"><span class="hljs-params">resp</span>=&gt;</span>&#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">teacherName</span>=resp.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">teacher</span>.<span class="hljs-property">name</span><br>              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">teacherName</span>)<br>            &#125;<br>          )<br><br>        &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br><br>        &#125;)<br>      &#125;,<br></code></pre></td></tr></table></figure><p>哪我们在什么时候使用mounted方法？<br><strong>mounted通常是在一些插件的使用或者组件的使用中进行操作 也就是页面渲染之后执行</strong> 通常情况下我们会在没有相应的点击事件，但需要在页面展示过程中去不断调用某一函数情况下使用。<br>比如说在常见的订单支付功能，我们点击立即付款后，跳转到付款页面。这是时候需要我们不断访问后端接口查看用户是否支付成功，支付成功后进行跳转。我们需要将查询函数的调用写在mounted函数中，并通过计时器不断调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><br> <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//页面渲染之后执行,设置为3s一更新</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer1</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">queryOrderStatus</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">payObj</span>.<span class="hljs-property">out_trade_no</span>)<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;,<br><span class="hljs-attr">methods</span>: &#123;<br> <br>    <span class="hljs-comment">//支付跳转</span><br>    <span class="hljs-title function_">queryOrderStatus</span>(<span class="hljs-params">orderNo</span>) &#123;<br>      orderApi.<span class="hljs-title function_">queryPayStatus</span>(orderNo)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">success</span>) &#123;<br>            <span class="hljs-comment">//支付成功，清除定时器</span><br>            <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer1</span>)<br>            <span class="hljs-comment">//提示</span><br>            <span class="hljs-variable language_">this</span>.$message(&#123;<br>              <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;success&#x27;</span>,<br>              <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;支付成功! 💴&#x27;</span><br>            &#125;)<br>            <span class="hljs-comment">//跳转回到课程详情页面</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<br>              <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/course/&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">payObj</span>.<span class="hljs-property">course_id</span><br>            &#125;)<br>          &#125;<br>        &#125;)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>定时器方法介绍</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">time1</span>=<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">queryPayStatus</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">this</span>.<span class="hljs-property">payObj</span>.<span class="hljs-property">out_trade_no</span>)<br>   &#125;,<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><p>​    setInterval()有两个参数一个是要执行的函数，一个是要执行的时间间隔单位为毫秒，此处函数采用箭头函数<br>​    ES5 语法如下<br>​    setInterval(function(){ alert(“Hello”); }, 3000);<br>​    将定时器赋给time 对象<br>​    清除定时器 clearInterval(this.time1)</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经济指标</title>
    <link href="/2023/03/02/%E7%BB%8F%E6%B5%8E%E6%8C%87%E6%A0%87/"/>
    <url>/2023/03/02/%E7%BB%8F%E6%B5%8E%E6%8C%87%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h4 id="1-要不要买黄金"><a href="#1-要不要买黄金" class="headerlink" title="1. 要不要买黄金"></a>1. 要不要买黄金</h4><ol><li>黄金是由名义利率和通胀水平同时构成的一个实际利率，实际上，实际利率 &#x3D; 名义利率 - 通胀水平，名义利率越低，黄金的价格会越高。</li><li>黄金的价格越高，隐含着实际利率越低；这也正是过去20年世界经济的状态，各个经济体的实际利率越来越低，甚至是负的，所以黄金价格越来越高。但是各个央行也会加息来提高其的实际利率，虽然是少数情况。</li><li>低利率带来的风险是，当通缩时，难以通过再通过货币政策去提振或者帮忙经济恢复到正常状态；因此在疫情期间，大多数国家借以财政政策来达到这个目的，比如直接发钱，但是这是以消耗国家货币信心为基础的（容易造成财政赤字，然后财政机制也像货币机制一样逐步失效）</li><li>美国70年代危机，保罗沃尔克就通过大幅度提升名义利率（加息）+经济结构性优化（用更强的实力证明你的信用很坚实、内政上大规模剔除僵尸性企业来完成美国从工业时代到信息时代的转变，苹果，亚马逊都是在80年代经济转型中完成蜕变。 外交上平定中东石油危机，美日贸易战。），来缓解信用危机。 财政赤字是对信用伤害最严重的一环。</li><li>任何的方式方法都没有永久的，而且在低利率情况(其实通货膨胀的本质就是货币量的增加，CPI没怎么涨，但是房价涨的很猛)下，更容易加剧贫富差距。</li></ol><h4 id="2-CPI"><a href="#2-CPI" class="headerlink" title="2. CPI"></a>2. CPI</h4><p>CPI: <strong>居民消费价格指数。</strong></p><ol><li>CPI反应与居民生活有关的产品和劳务价格统计出的物价变动指数。以百分比变化为表达形式。它是衡量<a href="https://zh.m.wikipedia.org/wiki/%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80">通货膨胀</a>的主要指标之一。一般定义超过3％为通货膨胀，超过5％就是比较严重的通货膨胀[<a href="https://zh.m.wikipedia.org/wiki/%E6%B6%88%E8%B2%BB%E8%80%85%E7%89%A9%E5%83%B9%E6%8C%87%E6%95%B8#cite_note-xinhua-2">2]</a>。</li></ol><img src="/2023/03/02/%E7%BB%8F%E6%B5%8E%E6%8C%87%E6%A0%87/%E4%B8%AD%E5%9B%BDcpi%E5%8C%85%E5%90%AB.png" class="" title="中国cpi包含"><p>中国CPI 中食品占比很大，失真（不能反映真实情况）严重。</p><ol start="2"><li><p>美国 CPI 篮子包括 8 大类商品和服务：食品与饮料、住宅（租金）、服装、交通运输、医疗保健、娱乐、教 育与通信、其他商品和服务。从 2021 年 3 月份数据来看，住宅权重最大（42%），其次为交通运输 （16%）、食品与饮料（15%）。 </p></li><li><p>中国 CPI 篮子包括 8 大类商品和服务：食品烟酒、衣着、居住（租金）、生活用品及服务、交通和通讯、教 育文化和娱乐、医疗保健、其他用品和服务。从 2021 年数据来看，居住、食品烟酒在 CPI 中权重较 大，分别为 22%、20%</p></li></ol><p><strong>中美CPI 中都不包含房价。</strong></p><p><strong>注意：CPI权重会根据时间，各国会进行调整。</strong></p><h4 id="3-PPI"><a href="#3-PPI" class="headerlink" title="3. PPI"></a>3. PPI</h4><p>PPI: 生产物价指数，指原材料和能源的价格。PPI比预期高，表明有通货膨胀的风险，PPI比预期低说明有通货紧缩的风险。</p><h4 id="4-社融"><a href="#4-社融" class="headerlink" title="4. 社融"></a>4. 社融</h4><ol><li><p>社会融资规模：是指<strong>实体经济从金融体系获得的资金</strong>。需要注意两点：一是，实体经济不仅仅指企业，还包括个人；二是，金融体系不仅仅指银行体系，还包括债券市场、股票市场等，如上市公司IPO融资，也属于社融范围。</p></li><li><p><strong>新增人民币贷款：是社融数据中占比最大的核心项目。</strong>社会融资主要包括表内业务（人民币贷款、外币贷款）、表外业务（信托、票据）、直接融资（债券、股票），其中人民币贷款占比66%，是社融核心项，所以每个月都会重点统计。</p></li></ol><p> 新增人民币贷款： 居民新增贷款(短+ 中长期（中长期主要指的是房贷）)、企事业单位新增贷款(短 + 中长期)</p><p>企业债券： 企业按照法定程序，在一定期限内需要还本付息的债券。</p><p><strong>社融下降意味着经济需求不足， 市场对未来预期不看好。</strong></p><p>中国2022年社融: </p><p>获取地址： </p><ol><li>国家统计局 ： <a href="http://www.stats.gov.cn/tjsj/zxfb/">http://www.stats.gov.cn/tjsj/zxfb/</a>  </li><li>中国人民银行 <a href="http://www.pbc.gov.cn/">http://www.pbc.gov.cn/</a></li><li>财政部： <a href="http://www.mof.gov.cn/gkml/caizhengshuju/">http://www.mof.gov.cn/gkml/caizhengshuju/</a></li></ol><img src="/2023/03/02/%E7%BB%8F%E6%B5%8E%E6%8C%87%E6%A0%87/image-20240302154310316.png" class="" title="社会融资规模增量统计表"><p>如表: 2022年12月社融相比于2021年12月腰斩，主要在于政府债券和企业债券大幅度缩水。政府债券主要是因为有一个前置发行的动作，大部分在上半年就已经发行完毕。2021年发行的也比较多。企业债券主要是理财产品经过大量的赎回，债券市场收益率上行，大量企业取消发行债券。 </p><h4 id="5-M0-M1-M2"><a href="#5-M0-M1-M2" class="headerlink" title="5. M0 M1 M2"></a>5. M0 M1 M2</h4><img src="/2023/03/02/%E7%BB%8F%E6%B5%8E%E6%8C%87%E6%A0%87/image-20240302154518447.png" class=""><p>通常使用 M2&#x2F; GDP 来度量货币的超发情况。M2可以看作基础货币 + 信贷货币。 1块钱基础货币可以派生出7块钱的信贷货币。 我国信贷扩张时货币增发的主要原因。</p><p><strong>注意： 中国M1 不包括个人活期存款。</strong></p><h4 id="6-外汇占款"><a href="#6-外汇占款" class="headerlink" title="6. 外汇占款"></a>6. 外汇占款</h4><p>外汇占款（Funds outstanding for foreign exchange）是指<strong>本国中央银行收购外汇资产而相应投放的本国货币</strong>。 央行用人民币购买外汇，增加货币供给，形成外汇占款。</p><p>外汇占款 是央行进行基础货币投放的重要手段之一。</p><p>外汇供给是企业因为出口而得到的外币储存在<a href="https://www.zhihu.com/search?q=%E5%95%86%E4%B8%9A%E9%93%B6%E8%A1%8C&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%2245011596%22%7D">商业银行</a>里，央行因为要<a href="https://www.zhihu.com/search?q=%E5%A4%96%E6%B1%87%E5%82%A8%E5%A4%87&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%2245011596%22%7D">外汇储备</a>，所以便需要用人民币从企业进行购买，于是产生人民币，<a href="https://www.zhihu.com/search?q=%E5%9F%BA%E7%A1%80%E8%B4%A7%E5%B8%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%2245011596%22%7D">基础货币</a>增加。</p><h4 id="7-基础货币"><a href="#7-基础货币" class="headerlink" title="7. 基础货币"></a>7. 基础货币</h4><p>基础货币是央行真实印出来的钱，在如下图，央行公布的资产负债表里，有一栏叫储备货币，差不多 29 万亿左右其实就是基础货币，其中 23.5 万亿货币发行，7 万亿本币。 货币发行”（流通中的现金M0与银行库存现金）， 其他存款性公司存款”（即准备金存款，包括法定存款准备金与超额存款准备金）基础货币的创造过程也是来源于央行资产端的扩张。</p><img src="/2023/03/02/%E7%BB%8F%E6%B5%8E%E6%8C%87%E6%A0%87/image-20240302154851944.png" class=""><p><strong>那么这 29万亿是怎么变出 149 万亿 M2？ 信贷</strong></p><p>持续更新中…..</p>]]></content>
    
    
    <categories>
      
      <category>经济</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经济</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
